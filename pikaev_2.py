# Создание собственного метода timer

# Теперь представим, что у нас есть еще один метод с определенной логикой, который также должен выполняться в потоках.
# Сделаем так, чтобы потоки выводили текущее время, включая день, месяц, год и время определенное количество раз.
# Для начала нам нужно импортировать модуль time. Затем добавим в метод ‘__init__()’ новый атрибут ‘counter’, который будет
# определять, сколько раз необходимо вывести текущее время (Рис.7).

import threading
import time

class MyThread(threading.Thread):
    def __init__(self, name, counter, delay):
        threading.Thread.__init__(self)
        self.name = name
        self.counter = counter
        self.delay = delay

    # После этого мы создадим новый метод ‘timer()’, в который будем передавать имя потока и значение ‘counter’. Внутри этого
    # метода мы реализуем цикл, который будет выполняться до тех пор, пока значение ‘counter’ не станет равным нулю

    # Однако, чтобы добавить разнообразия и избежать одинаковой работы потоков, мы передадим в метод ‘timer()’ параметр
    # ‘delay’. Это будет задержка, которая позволит установить разное время паузы между выводами для каждого потока. Внутри
    # метода мы вызовем ‘time.sleep()’ с определённым значением задержки, а также выведем имя потока вместе с текущей датой
    # и временем. Для этого воспользуемся методом ‘ctime()’, передавая в него значение, полученное из ‘time.time()’

    def timer(self, name, counter, delay):
        while counter:
            time.sleep(delay)
            print(f'{name} {time.ctime(time.time())}')
            counter -= 1


    # Таким образом, при создании потока необходимо передавать не только имя, но и значение счетчика, указывающее, сколько
    # раз будет выполнен вывод времени. В методе ‘run()’ мы будем вызывать метод ‘timer()’, передавая ему как счетчик, так и
    # значение задержки (паузу)

    # Кроме того, мы можем добавить возможность задавать паузу при инициализации потока, чтобы она была различной для
    # каждого потока. Это добавит еще больше разнообразия в выполнение программы (Рис.9)

    # Создание потоков

    # Теперь создадим два потока: ‘thread1’ и ‘thread2’. Как мы знаем, чтобы запустить каждый поток, необходимо вызвать метод
    # ‘start()’. Этот метод не только запускает поток, но и автоматически вызывает метод ‘run()’, который содержит логику работы
    # потока (Рис.5)

    def run(self):
        print(f'Поток {self.name} запущен')
        self.timer(self.name, self.counter, self.delay)
        print(f'Поток {self.name} завершён')

# Вызовы внес под main, во избежание запуска при импорте
if __name__ == '__main__':

    thread1 = MyThread('thread1', 5,1)
    thread2 = MyThread('thread2',3,0.5)

    thread1.start()
    thread2.start()




